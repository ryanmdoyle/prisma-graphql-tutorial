"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ModelOrderNormalizer = /** @class */ (function () {
    function ModelOrderNormalizer(baseModel) {
        this.baseModel = baseModel;
    }
    ModelOrderNormalizer.prototype.normalize = function (model) {
        var _this = this;
        var e_1, _a;
        var baseTypes = this.baseModel !== null ? this.baseModel.types : [];
        model.types = model.types.sort(function (a, b) {
            return _this.typeOrderComparer(baseTypes, a, b);
        });
        var _loop_1 = function (type) {
            var baseType = this_1.baseModel === null
                ? undefined
                : this_1.baseModel.types.find(function (x) { return x.name === type.name; });
            if (baseType === undefined) {
                // Alphabetically is fallback.
                type.fields = type.fields.sort(function (a, b) {
                    return _this.fieldOrderComparer([], a, b);
                });
            }
            else {
                type.fields = type.fields.sort(function (a, b) {
                    return _this.fieldOrderComparer(baseType.fields, a, b);
                });
            }
        };
        var this_1 = this;
        try {
            for (var _b = __values(model.types), _c = _b.next(); !_c.done; _c = _b.next()) {
                var type = _c.value;
                _loop_1(type);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return model;
    };
    ModelOrderNormalizer.prototype.typeOrderComparer = function (ref, a, b) {
        // Should we also compare for enum?
        var ia = ref.findIndex(function (x) { return x.name === a.name || x.databaseName === a.name; });
        var ib = ref.findIndex(function (x) { return x.name === b.name || x.databaseName === b.name; });
        // If both types or fields are present in the reference,
        // compare by index. Else, append to back and compare by name.
        if (ia === -1 && ib === -1) {
            return a.name > b.name ? 1 : -1;
        }
        else if (ia === -1) {
            return 1;
        }
        else if (ib === -1) {
            return -1;
        }
        else {
            return ia > ib ? 1 : -1;
        }
    };
    ModelOrderNormalizer.prototype.fieldOrderComparer = function (ref, a, b) {
        var ia = ref.findIndex(function (x) { return x.name === a.name || x.databaseName === a.name; });
        var ib = ref.findIndex(function (x) { return x.name === b.name || x.databaseName === b.name; });
        // If both types or fields are present in the reference,
        // compare by index. Else, append to back and compare by name.
        // Id's always get prepended, if the ID field is new.
        if (ia === -1 && a.isId) {
            return -1;
        }
        else if (ib === -1 && b.isId) {
            return 1;
        }
        else if (ia === -1 && ib === -1) {
            return a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
        }
        else if (ia === -1) {
            return 1;
        }
        else if (ib === -1) {
            return -1;
        }
        else {
            return ia < ib ? -1 : 1;
        }
    };
    return ModelOrderNormalizer;
}());
exports.default = ModelOrderNormalizer;
//# sourceMappingURL=modelOrderNormalizer.js.map